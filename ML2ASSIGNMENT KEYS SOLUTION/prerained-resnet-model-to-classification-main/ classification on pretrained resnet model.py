# -*- coding: utf-8 -*-
"""ML2Q2(part-A).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BzD7-ZSEZbRHfRXkOiGn2x7JcFx25uXh

Dharamvir ramroop yadav (MT19CPS012) assignment 2 : question 2(partA)
"""

import torch
import torchvision
import torchvision.transforms as transforms

transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])

trainset = torchvision.datasets.CIFAR10(root='./data', 
                                        train=True,
                                        download=True, 
                                        transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, 
                                          batch_size=1000,
                                          shuffle=True)

label2 = []
for image , label in trainloader:
    label1 = []
    for i in label:
        if i!= 1:
           j= 0
           label1.append(j)
        else:

           label1.append(i)
    label2 = label2 + label1

final_label = torch.FloatTensor(label2)

import numpy as np

import torch
import torch.nn as nn
import torchvision.models as models
from torch.autograd import Variable
resnet50 = models.resnet50(pretrained=True)
modules=list(resnet50.children())[:-1]
resnet50=nn.Sequential(*modules)
for p in resnet50.parameters():
    p.requires_grad = False

from tqdm import tqdm

first_tensor = torch.zeros((0,2048))
for i, data in tqdm(enumerate(trainloader, 0)):
    inputs, labels = data
  
    features_var = resnet50(inputs)
    features_var = torch.reshape(features_var,(1000,2048))
    
    
    first_tensor = torch.vstack((first_tensor,features_var))
    #feature_tensor= tf.concat(0, [first_tensor, feature_var])

testset = torchvision.datasets.CIFAR10(root='./data', 
                                       train=False,
                                       download=True, 
                                       transform=transform)
testloader = torch.utils.data.DataLoader(testset, 
                                         batch_size=1000,
                                         shuffle=False)

first_tensor1 = torch.zeros((0,2048))
for i, data in tqdm(enumerate(testloader, 0)):
    inputs, labels = data
  
    features_var = resnet50(inputs)
    features_var = torch.reshape(features_var,(1000,2048))
    
    
    first_tensor1 = torch.vstack((first_tensor1,features_var))
    #feature_tensor= tf.concat(0, [first_tensor, feature_var])

!wget https://developer.nvidia.com/compute/cuda/9.0/Prod/local_installers/cuda-repo-ubuntu1704-9-0-local_9.0.176-1_amd64-deb
!ls  # Check if required cuda 9.0 amd64-deb file is downloaded
!dpkg -i cuda-repo-ubuntu1704-9-0-local_9.0.176-1_amd64-deb
!ls /var/cuda-repo-9-0-local | grep .pub
!apt-key add /var/cuda-repo-9-0-local/7fa2af80.pub
!apt-get update
!sudo apt-get install cuda-9.0

!pip install thundersvm

#import thundersvm
from thundersvm import SVC

model = SVC(C=100, kernel='rbf')
model.fit(first_tensor, final_label)

svm_prediction = model.predict(first_tensor1)

svm_probability = model.predict_proba(first_tensor1)

label_test2 = []
for image , label in testloader:
    label1 = []
    for i in label:
        if i!= 1:
           j= 0
           label1.append(j)
        else:

           label1.append(i)
    label_test2 = label_test2 + label1

final_test_label = np.array(label_test2)

# accuracy 


def accuracy(true_labels , svm_labels):
  accu_score = 0
  if len(true_labels) != len(svm_labels):
      return print('Dimension Error')
  for i in range(len(true_labels)):

    if true_labels[i] == svm_labels[i]:
      accu_score += 1

  return (accu_score / len(true_labels) ) *100 




def confusion_matrix(true_labels , svm_labels):
    
    tp = 0
    fp = 0 
    tn = 0 
    fn = 0 
    
    
    if len(true_labels) != len(svm_labels):
      return print('Dimension Error')
      
    for i in range(len(true_labels)):
        
        if true_labels[i] == svm_labels[i] == 1:
            tp += 1
            
        if true_labels[i] == svm_labels[i] == 0:
            tn += 1
            
        if true_labels[i] == 1 and  svm_labels[i] == 0:
            fn += 1
        
        if true_labels[i] == 0 and  svm_labels[i] == 1:
            fp += 1
            
            
            
    Confusion_Matrix = [[tp , fp] , [fn , tn]]
    
    return Confusion_Matrix
            
        
      
print('Accuracy is {}'.format(accuracy(final_test_label,svm_prediction)))

print('Confusion Matrix is {}'.format(confusion_matrix(final_test_label,svm_prediction)))

def roc(true_label , predicted_proba):
  
  thresh = np.sort(predicted_proba , 0 )

  

  tpr_vs_fpr = [ ]

  for th in thresh:

    print('th is {}'.format(th))

    # converet to labels 

    temp_labels = [ ]

    for i in predicted_proba:

      if i <= th:
        temp_labels.append(0)

      else:
        temp_labels.append(1)


    
    # compute tpr and fpr 

    temp_cm = confusion_matrix( temp_labels,svm_prediction)
    #print(type(temp_cm))
    temp_cm = np.array(temp_cm)

    tpr = temp_cm[0][0] / temp_cm[0][0]  + temp_cm[1][0]   # tp / tp + fn 
    fpr = temp_cm[0][1] / temp_cm[0][1]  + temp_cm[1][1]   # fp / fp + tn 



    tpr_vs_fpr.append([tpr,fpr])



  return tpr_vs_fpr

tpr_vs_fpr = roc(svm_prediction,svm_probability)

import matplotlib.pyplot as plt

plt.plot(tpr_vs_fpr)

